{% extends "layout.html" %}
{% block content %}
<style>
  .page-header { display:flex; align-items:center; justify-content:space-between; gap:.75rem; margin-bottom:1rem; flex-wrap:wrap; }
  .actions { display:flex; gap:.5rem; align-items:center; flex-wrap:wrap; }
  .search { max-width:260px; }

  .stat-card { border:1px solid #e9ecef; border-radius:.75rem; padding:.9rem; }
  .muted { color:#6c757d; }
  .chip { padding:.15rem .5rem; border-radius:999px; border:1px solid #e9ecef; font-size:.85rem; }
  .k { color:#6c757d; font-size:.85rem; }
  .v { font-variant-numeric: tabular-nums; }
  .mono { font-variant-numeric: tabular-nums; }

  .grid-ctx { display:grid; gap:.8rem 1rem; grid-template-columns: repeat(4, minmax(140px, 1fr)); }

  /* table */
  .explorer-table { width:100%; border-collapse:collapse; }
  .explorer-table th, .explorer-table td { padding:.55rem .6rem; border-bottom:1px solid #edf2f7; font-variant-numeric: tabular-nums; }
  .explorer-table th { text-align:left; font-weight:600; background:#fafbfc; position:sticky; top:0; z-index:1; cursor:pointer; }
  .explorer-up { color:#1e7e34; font-weight:600; }
  .explorer-down { color:#c0392b; font-weight:600; }

  .spark { display:flex; gap:1px; height:18px; align-items:flex-end; }
  .spark > i { display:block; width:6px; background:#cfe2ff; border-radius:2px 2px 0 0; }

  /* links */
  .name-link { color:#0d6efd; cursor:pointer; text-decoration: underline dotted transparent; }
  .name-link:hover { text-decoration-color:#0d6efd66; }

  /* level colors for quick scan */
  :root{ --lvl1:#0d6efd; --lvl2:#0ca678; --lvl3:#f76707; --lvl4:#7048e8; }
  .lvl-1 .path { color:var(--lvl1); }
  .lvl-2 .path { color:var(--lvl2); }
  .lvl-3 .path { color:var(--lvl3); }
  .lvl-4 .path { color:var(--lvl4); }

  .indent { display:inline-block; width: var(--indent, 0px); }
  .pill { padding:.15rem .5rem; border-radius:999px; border:1px solid #e9ecef; font-size:.85rem; }

  /* selection row */
  .sel-sum { display:flex; gap:1rem; align-items:center; flex-wrap:wrap; }
  .sel-sum .card { border:1px solid #e9ecef; border-radius:.65rem; padding:.5rem .65rem; background:#fff; }

  /* footer info */
  .tiny { font-size:.85rem; color:#6c757d; }

  /* pretty path chips */
  .path-cell { display:flex; align-items:center; gap:.35rem; flex-wrap:wrap; }
  .path-chip {
    display:inline-block; padding:.15rem .45rem;
    border-radius:999px; border:1px solid #dee5ff; background:#eef2ff;
    color:#0a58ca; font-weight:600; line-height:1;
  }
  .path-chip.level-0 { background:#e7f1ff; border-color:#cfe2ff; }
  .path-chip.level-1 { background:#ecf8ff; border-color:#d6efff; }
  .path-chip.level-2 { background:#f2ffef; border-color:#d6ffd0; }
  .path-chip.level-3 { background:#fff7e6; border-color:#ffe2b5; }
  .path-sep { color:#b6c0ff; margin:0 .15rem; user-select:none; }
</style>

<div class="container mt-4">
  <div class="page-header">
    <h3 class="m-0">All Items Explorer</h3>
    <div class="actions">
      <input id="search" class="form-control form-control-sm search" placeholder="Search path…">
      <select id="scope" class="form-select form-select-sm">
        <option value="leaves" selected>Leaves only</option>
        <option value="all">All nodes</option>
        <option value="top">Top-level only</option>
      </select>
      <select id="topFilter" class="form-select form-select-sm">
        <option value="">All top levels</option>
      </select>
      <select id="baseline" class="form-select form-select-sm" title="Forecast method">
        <option value="3" selected>Forecast: 3-mo avg</option>
        <option value="6">Forecast: 6-mo avg</option>
      </select>

      <div class="btn-group btn-group-sm" role="group" aria-label="Row selection">
        <button id="selectVisible" class="btn btn-outline-secondary">Select visible</button>
        <button id="clearSelection" class="btn btn-outline-secondary">Clear selection</button>
      </div>
    </div>
  </div>

  <!-- Selection summary / forecast -->
  <div class="stat-card mb-2">
    <div class="sel-sum">
      <div class="card"><div class="tiny">Selected</div><div class="mono fs-6" id="selCount">0 items</div></div>
      <div class="card"><div class="tiny">Selected total (12m)</div><div class="mono fs-6" id="selTotal">$0</div></div>
      <div class="card"><div class="tiny">Projected next month</div><div class="mono fs-6" id="selForecast">$0</div></div>
      <div class="ms-auto tiny">Tip: click a row’s <em>manage</em> to open the drawer on that path.</div>
    </div>
  </div>

  <!-- Context overview -->
  <div class="stat-card mb-2">
    <div class="d-flex align-items-center gap-2 mb-2">
      <span class="pill">Universe</span>
      <span class="muted small" id="monthsLabel"></span>
      <span class="muted small ms-auto" id="rowCount"></span>
    </div>
    <div class="grid-ctx" id="ctxGrid"></div>
  </div>

  <!-- Table -->
  <div class="stat-card">
    <table id="table" class="explorer-table">
      <thead>
        <tr>
          <th style="width:36px;"><input type="checkbox" id="toggleAll"></th>
          <th data-sort="path">Path</th>
          <th data-sort="total">Total (12m)</th>
          <th data-sort="avg">Avg / mo</th>
          <th data-sort="last">Last mo</th>
          <th data-sort="forecast">Next mo (forecast)</th>
          <th data-sort="mom">MoM</th>
          <th data-sort="vol">Volatility</th>
          <th>Spark</th>
          <th>Manage</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
    <div class="tiny mt-2">Sorting works on any header; filters don’t reset selection so you can build a set across the tree.</div>
  </div>
</div>

<!-- Data bootstrap -->
<script id="catMonthlyData" type="application/json">
{{ (cat_monthly | default({})) | tojson }}
</script>

<script>
(function(){
  'use strict';

  /* ---------- helpers ---------- */
  const fmt = new Intl.NumberFormat(undefined, { style:'currency', currency:'USD', maximumFractionDigits:0 });
  const toNum = (v)=> (typeof v === 'number' && isFinite(v)) ? v : (Number(String(v||'').replace(/[$,]/g,'')) || 0);
  const stdev = (arr)=>{ const n=arr.length; if(n<2) return 0; const mean=arr.reduce((a,b)=>a+toNum(b),0)/n;
    const v=arr.reduce((s,v)=>s+(toNum(v)-mean)**2,0)/(n-1); return Math.sqrt(v); };
  const sparkline = (arr)=>{ const max=Math.max(...arr.map(v=>Math.abs(toNum(v))),1);
    return '<div class="spark">'+arr.map(v=>`<i style="height:${Math.round((Math.abs(toNum(v))/max)*18)}px"></i>`).join('')+'</div>'; };
  const pctText = (v)=> (v==null || !isFinite(v)) ? '—' : (v*100).toFixed(1)+'%';
  const avgLastK = (arr, k)=>{ const n=arr.length; if(!n) return 0; let used=0, sum=0;
    for(let i=n-1; i>=0 && used<k; i--){ sum += toNum(arr[i]); used++; }
    return used ? (sum/used) : 0; };

  /* Only treat " / " (space-slash-space) as a path separator */
  function splitPathName(raw){
    const s = String(raw ?? '');
    return s.includes(' / ') ? s.split(' / ').map(x => x.trim()).filter(Boolean) : [s];
  }

  /* NEW: last closed month index (uses month before the most recent slot) */
  function lastClosedIdx(){
    return months.length >= 2 ? months.length - 2 : Math.max(0, months.length - 1);
  }

  /* chips + drawer ctx helpers */
  function renderPathChipsFromSegs(segs){
    if (!segs || !segs.length) return '';
    return segs
      .map((s,i)=>`<span class="path-chip level-${i}">${s}</span>`)
      .join('<span class="path-sep">›</span>');
  }
  function ctxFromSegs(segs){
    return {
      level: ['category','subcategory','subsubcategory','subsubsubcategory'][Math.min((segs?.length||1)-1,3)] || 'category',
      cat: segs?.[0] || '', sub: segs?.[1] || '', ssub: segs?.[2] || '', sss: segs?.[3] || ''
    };
  }

  /* ---------- build tree + rollups ---------- */
  function buildTree(categories){
    const root = { key:'__ROOT__', name:'All Categories', path:[], monthly:[], total:0, parent:null, children:[] };
    const map = new Map(); map.set('', root);

    function segKey(segs){ return segs.join(' / '); }
    function getNode(segs){
      const p = segKey(segs);
      if (map.has(p)) return map.get(p);
      const node = { key: encodeURIComponent(p), name: segs[segs.length-1], path:[...segs], monthly:[], total:0, parent:null, children:[] };
      const parent = getNode(segs.slice(0,-1));
      node.parent = parent; parent.children.push(node);
      map.set(p, node); return node;
    }

    categories.forEach(c=>{
      const segs = splitPathName(c.name);            /* <-- FIXED */
      const leaf = getNode(segs.length?segs:[c.name||'']);
      const m = (c.monthly||[]).map(toNum);
      leaf.monthly = m.slice();
      leaf.total   = m.reduce((a,b)=>a+b,0);
    });

    function roll(node){
      if (!node.children.length) return;
      const L = Math.max(...node.children.map(ch => (ch.monthly||[]).length), 0);
      let agg = new Array(L).fill(0);
      node.children.forEach(ch=>{
        roll(ch);
        const cm = ch.monthly||[]; for(let i=0;i<L;i++){ agg[i] += toNum(cm[i]||0); }
      });
      node.monthly = agg;
      node.total = agg.reduce((a,b)=>a+b,0);
    }
    roll(root);
    return root;
  }

  function gatherNodes(root, scope){
    const out = [];
    function isLeaf(n){ return n.children.length === 0; }
    function isTop(n){ return n.parent && n.parent.key === '__ROOT__'; }
    function visit(n){
      if (n !== root){
        if (scope === 'leaves' && !isLeaf(n)) { /* skip */ }
        else if (scope === 'top' && !isTop(n)) { /* skip */ }
        else out.push(n);
      }
      n.children.forEach(visit);
    }
    visit(root);
    return out;
  }

  /* ---------- state ---------- */
  const tableBody = document.querySelector('#table tbody');
  const monthsLabel = document.getElementById('monthsLabel');
  const ctxGrid = document.getElementById('ctxGrid');
  const rowCount = document.getElementById('rowCount');

  const searchEl = document.getElementById('search');
  const scopeEl = document.getElementById('scope');
  const topFilterEl = document.getElementById('topFilter');
  const baselineEl = document.getElementById('baseline');
  const toggleAllEl = document.getElementById('toggleAll');

  const selCount = document.getElementById('selCount');
  const selTotal = document.getElementById('selTotal');
  const selForecast = document.getElementById('selForecast');

  let root = null, months = [];
  let sort = { key:'total', dir:'desc' };
  let q = '', scope='leaves', topFilter='', baseline=3;
  const selected = new Set();

  /* ---------- render ---------- */
  function fmtMoM(arr){
    const L = lastClosedIdx();
    const P = L - 1;
    if (L < 0 || P < 0) return null;
    const prev = toNum(arr[P]); if (prev === 0) return null;
    return (toNum(arr[L]) - prev) / Math.abs(prev);
  }
  function volatility(arr){
    if (!arr.length) return null;
    const mean = arr.reduce((a,b)=>a+toNum(b),0) / arr.length || 0;
    if (mean === 0) return null;
    return stdev(arr) / Math.abs(mean);
  }
  function topOf(node){
    let n=node; while (n.parent && n.parent.key !== '__ROOT__') n = n.parent;
    return n.parent ? n : null;
  }

  function currentUniverse(){
    const all = gatherNodes(root, scope);
    const qq = q.trim().toLowerCase();
    return all.filter(n=>{
      if (topFilter && (topOf(n)?.name || '') !== topFilter) return false;
      if (qq && !(n.path.join(' / ').toLowerCase().includes(qq))) return false;
      return true;
    });
  }

  function renderUniverseHeader(nodes){
    const grand = nodes.reduce((a,n)=> a + (n.total||0), 0);
    const li    = lastClosedIdx();
    const last  = months.length ? nodes.reduce((a,n)=> a + toNum(n.monthly[li]||0), 0) : 0;
    ctxGrid.innerHTML = `
      <div><div class="k">Rows</div><div class="v">${nodes.length}</div></div>
      <div><div class="k">Total (12m)</div><div class="v">${fmt.format(grand)}</div></div>
      <div><div class="k">Avg / mo</div><div class="v">${fmt.format(grand/Math.max(1, months.length||12))}</div></div>
      <div><div class="k">Last month (sum)</div><div class="v">${fmt.format(last)}</div></div>
    `;
    rowCount.textContent = `${nodes.length} row${nodes.length===1?'':'s'}`;
  }

  function forecastNext(arr, k){
    if (!arr.length) return 0;
    return avgLastK(arr, k || 3);
  }

  function levelClass(n){
    const d = n.path.length; // 1..4
    return 'lvl-'+Math.min(d,4);
  }

  function manageCtxFor(n){
    const segs = n.path || [];
    return {
      level: ['category','subcategory','subsubcategory','subsubsubcategory'][Math.min(segs.length-1,3)] || 'category',
      cat: segs[0]||'', sub: segs[1]||'', ssub: segs[2]||'', sss: segs[3]||''
    };
  }

  function render(){
    const rows = currentUniverse();

    if (months.length){
      monthsLabel.textContent = months[0] + ' … ' + months[months.length-1];
      const li = lastClosedIdx();
      monthsLabel.title = 'Last month used in table: ' + (months[li] || '');
    }

    rows.sort((a,b)=>{
      const mul = (sort.dir==='asc'?1:-1);
      if (sort.key === 'path') return mul * a.path.join(' / ').localeCompare(b.path.join(' / '));
      if (sort.key === 'total') return mul * ((a.total||0) - (b.total||0));
      if (sort.key === 'avg') return mul * ((avgLastK(a.monthly, months.length||12)) - (avgLastK(b.monthly, months.length||12)));
      if (sort.key === 'last') {
        const li = lastClosedIdx();
        return mul * (toNum(a.monthly[li]||0) - toNum(b.monthly[li]||0));
      }
      if (sort.key === 'forecast') return mul * (forecastNext(a.monthly, baseline) - forecastNext(b.monthly, baseline));
      if (sort.key === 'mom'){
        const ma=fmtMoM(a.monthly), mb=fmtMoM(b.monthly);
        return mul * ((ma||0) - (mb||0));
      }
      if (sort.key === 'vol'){
        const va=volatility(a.monthly)||0, vb=volatility(b.monthly)||0;
        return mul * (va - vb);
      }
      return 0;
    });

    renderUniverseHeader(rows);

    if (!topFilterEl.dataset.bound){
      const tops = [...new Set(root.children.map(c=>c.name))].sort((a,b)=>a.localeCompare(b));
      tops.forEach(name=>{
        const opt = document.createElement('option'); opt.value = name; opt.textContent = name;
        topFilterEl.appendChild(opt);
      });
      topFilterEl.dataset.bound = '1';
    }

    const html = rows.map(n=>{
      const pathStr = n.path.join(' / ');
      const li   = lastClosedIdx();
      const last = months.length ? toNum(n.monthly[li]||0) : 0;
      const mom  = fmtMoM(n.monthly);
      const vol  = volatility(n.monthly);
      const fc   = forecastNext(n.monthly, baseline);
      const checked = selected.has(n.key) ? 'checked' : '';
      const lvlCls = levelClass(n);
      const indentPx = Math.max(0, (n.path.length-1) * 14);

      return `<tr class="${lvlCls}">
        <td><input type="checkbox" class="rowcheck" data-key="${n.key}" ${checked}></td>
        <td class="mono">
          <div class="path-cell">
            <span class="indent" style="--indent:${indentPx}px"></span>
            ${renderPathChipsFromSegs(n.path)}
          </div>
        </td>
        <td class="mono">${fmt.format(n.total||0)}</td>
        <td class="mono">${fmt.format(avgLastK(n.monthly, months.length||12))}</td>
        <td class="mono">${fmt.format(last)}</td>
        <td class="mono">${fmt.format(fc)}</td>
        <td>${mom==null ? '—' : (mom>0?'<span class="explorer-up">':'<span class="explorer-down">')+(mom*100).toFixed(1)+'%</span>'}</td>
        <td>${vol==null ? '—' : (vol*100).toFixed(0)+'%'}</td>
        <td>${sparkline(n.monthly||[])}</td>
        <td>
          <a href="#" class="name-link manage" data-key="${n.key}" data-manage-path="${pathStr}">manage</a>
        </td>
      </tr>`;
    }).join('');

    tableBody.innerHTML = html;
    refreshSelectionSummary();
  }

  function refreshSelectionSummary(){
    const rowsByKey = new Map();
    gatherNodes(root,'all').forEach(n=> rowsByKey.set(n.key, n));

    let total=0, forecast=0, count=0;
    selected.forEach(k=>{
      const n = rowsByKey.get(k); if (!n) return;
      total += (n.total||0);
      forecast += avgLastK(n.monthly, baseline);
      count++;
    });

    selCount.textContent = `${count} item${count===1?'':'s'}`;
    selTotal.textContent = fmt.format(total);
    selForecast.textContent = fmt.format(forecast);
  }

  /* ---------- events ---------- */
  document.querySelectorAll('#table th[data-sort]').forEach(th=>{
    th.addEventListener('click', ()=>{
      const key=th.dataset.sort;
      sort = (sort.key===key && sort.dir==='desc') ? {key, dir:'asc'} : {key, dir:'desc'};
      render();
    });
  });

  tableBody.addEventListener('change', (e)=>{
    const box = e.target.closest('.rowcheck'); if (!box) return;
    const k = box.dataset.key;
    if (box.checked) selected.add(k); else selected.delete(k);
    refreshSelectionSummary();
  });

  tableBody.addEventListener('click', (e)=>{
    const m = e.target.closest('.manage'); if (!m) return;
    e.preventDefault();

    const pathStr = m.getAttribute('data-manage-path') || '';
    if (pathStr){
      const segs = splitPathName(pathStr);          /* <-- FIXED */
      const ctx = ctxFromSegs(segs);
      if (window.openCategoryManager) window.openCategoryManager(ctx);
      return;
    }

    const k = m.dataset.key;
    let hit = null;
    (function find(n){
      if (hit) return;
      if (n.key === k) { hit = n; return; }
      n.children.forEach(find);
    })(root);
    if (!hit) return;
    const ctx = ctxFromSegs(hit.path);
    if (window.openCategoryManager) window.openCategoryManager(ctx);
  });

  document.getElementById('selectVisible').addEventListener('click', ()=>{ currentUniverse().forEach(n=> selected.add(n.key)); render(); });
  document.getElementById('clearSelection').addEventListener('click', ()=>{ selected.clear(); render(); });
  document.getElementById('toggleAll').addEventListener('change', ()=>{
    if (toggleAll.checked){ currentUniverse().forEach(n=> selected.add(n.key)); }
    else { currentUniverse().forEach(n=> selected.delete(n.key)); }
    render();
  });

  document.getElementById('search').addEventListener('input', (e)=>{ q = e.target.value.trim(); render(); });
  document.getElementById('scope').addEventListener('change', ()=>{ scope = scopeEl.value; render(); });
  document.getElementById('topFilter').addEventListener('change', ()=>{ topFilter = topFilterEl.value; render(); });
  document.getElementById('baseline').addEventListener('change', ()=>{ baseline = Number(baselineEl.value)||3; refreshSelectionSummary(); render(); });

  /* ---------- boot ---------- */
  (function main(){
    let j = null;
    try { const el = document.getElementById('catMonthlyData'); j = el ? JSON.parse(el.textContent || 'null') : null; }
    catch(err){ console.error('Failed to parse cat_monthly JSON:', err); }

    if (!j || !Array.isArray(j.months) || !Array.isArray(j.categories)) {
      const tbody = document.querySelector('#table tbody');
      if (tbody) tbody.innerHTML = '<tr><td colspan="10" class="muted">No data injected (cat_monthly). Ensure your Flask view passes {"months":[],"categories":[...]}</td></tr>';
      return;
    }

    months = j.months || [];
    root   = buildTree((j.categories||[]).map(c=>({ name:c.name, monthly:(c.monthly||[]).map(toNum) })));
    render();
  })();
})();
</script>
{% endblock %}
